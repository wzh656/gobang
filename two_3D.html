<!DOCTYPE html>
<!-- Copyright © 2021 by wzh -->
<html lang="zh">
	<head>
		<meta charset="UTF-8" />
		<meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" name="viewport" />
		<title>双人对战 | 3D五子棋</title>
		
		<!--icon-->
		<link href="./img/icon.png" rel="icon" type="image/x-icon"/>
		
		<!-- 异步fonts加载 -->
		<script src="./js/webfontloader.js"></script>
		<script>
		if (typeof require != "undefined"){ //electron
			console.log("electron")
			document.write(`<link href="./css/fonts.css" rel="stylesheet" type="text/css" />`);
			window.onload = function(){
				console.log("onload")
				$("body").addClass("wf-active");
			}
		}else{
			WebFont.load({
				google: {
					families: ["kt", "st", "xs", "zyyt"],
					api: "./css/fonts.css"
				}
			});
		}
		</script>
		
		<style>
		/* 字体缩放方案 */
		/* @media screen and (max-width:320px){
			body {font-size: calc(0.018 * 320px + 6px) !important;}
		}
		body{
			font-size: calc(1.8vw + 6px) !important;
		}
		@media screen and (min-width: 960px){
			body {font-size: calc(0.018 * 960px + 6px) !important;}
		} */
		
		/* element */
		*{
			outline: none; /* 无点击线 */
		}
		html{
			/* 禁止选择 */
			-moz-user-select: none;
			-khtml-user-select: none;
			user-select: none;
			
			background-color: #fffae8; /* 背景 */
		}
		html.outDown{
			min-height: 100%;
			background: #1b2036 url("./img/background.jpg") no-repeat fixed center;
			background-size: cover;
			max-width: 100%;
			margin: auto;
			
			overflow-y: hidden;
		}
		
		body{
			position: absolute;
			width: 100%;
			height: 100%;
			left: 0;
			top: 0;
			margin: 0;
			
			display: flex;
			flex-direction: column;
			
			background-color: #fffae8; /* 背景 */
			
			opacity: 0; /* 完全透明 */
			transition: opacity 1s, top 0.6s; /* 出入动画 */
		}
		html.fadeIn > body{
			opacity: 1; /* 不透明 */
		}
		html.outDown > body{
			top: 100%; /* 下滑 */
			overflow-y: hidden;
		}
		
		
		/* header */
		body > header{
			flex: none;
			display: flex;
			width: 100%;
			z-index: 1;
			background-color: #aef;
		}
		body > header > i{
			flex: none;
			padding: 0.3rem;
			font-size: 2em !important;
			font-weight: bold;
			
			background-color: #aef;
			border: none;
			transition: background-color 0.3s;
		}
		body > header > i:focus{
			background-color: #afe;
		}
		body > header > i:active{
			background-color: #9ed;
		}
		body > header > h1{
			display: inline-block;
			width: 100%;
			margin: 0;
			padding: 6px 0;
			text-align: center;
			font-weight: bold;
		}
		
		
		/* main */
		#main{
			margin: 8px;
			
			display: flex;
			flex-direction: column;
		}
		
		/* 双方 */
		#main > div.side{
			display: flex;
			align-items: center;
			z-index: 1;
		}
		#main > div.opposite{
			text-align: left;
			justify-content: flex-start;
		}
		#main > div.self{
			text-align: right;
			justify-content: flex-end;
		}
		
		#main > div.side > i{ /* 图标 */
			display: inline-block;
			width: 1.8rem;
			height: 1.8rem;
			margin: 0.1rem;
			border-radius: 50%;
		}
		#main > div.black > i{ /* 黑 */
			background-color: black;
			border: 1px solid white;
		}
		#main > div.white > i{ /* 白 */
			background-color: white;
			border: 1px solid black;
		}
		
		#main > div.side > div{
			display: inline-flex;
			flex-direction: column;
		}
		
		#main > div.side > div > p.name{ /* 名称 */
			display: inline-block;
			margin: 0.1rem;
			font-weight: bold; /* 粗体 */
		}
		#main > div.black > div > p.name:before{ /* 黑 */
			content: "黑方";
		}
		#main > div.white > div > p.name:before{ /* 白 */
			content: "白方";
		}
		
		#main > div.side > div > p.time{ /* 时长 */
			display: inline-block;
			margin: 0.1rem;
		}
		
		/* 棋盘 */
		#board{
			position: absolute;
			display: block;
			left: 0;
			top: 0;
			width: 100%;
			height: 100%;
		}
		
		/* 控制 */
		#layerControl{ /*显示层控制*/
			position: absolute;
			left: 1rem;
			bottom: 8rem;
			display: flex;
			flex-direction: column;
			
			border: 1px solid #000;
			border-radius: 0.3rem;
			font-size: 6em !important;
		}
		#layerControl > *{
			padding: 0.3rem;
		}
		#layerControl > *:first-child{
			border-bottom: 1px solid #000;
		}
		#layerControl > *:active{
			background-color: #eee;
		}
		#heightControl{
			position: absolute;
			right: 1rem;
			bottom: 8rem;
			display: flex;
			flex-direction: column;
			
			border: 1px solid #000;
			border-radius: 0.3rem;
			font-size: 6em !important;
		}
		#heightControl > *{
			padding: 0.3rem;
		}
		#heightControl > *:first-child{
			border-bottom: 1px solid #000;
		}
		#heightControl > *:active{
			background-color: #eee;
		}
		
		/* 工具按钮 */
		#toolBtn{
			z-index: 1;
		}
		#toolBtn > button{
			width: 2.8rem;
			height: 2.8rem;
			margin: 0.1rem;
			font-size: 1em;
			
			background-color: #fc7;
			border: 1px solid #c94;
			border-radius: 50%;
			transition: background-color 0.3s;
			box-shadow: 1px 1px 2px #888,
				3px 3px 2px #888;
		}
		#toolBtn > button:active{
			background-color: #eb6;
			box-shadow: 3px 3px 3px #888;
		}
		
		/* 工具 */
		#tools{
			z-index: 1;
		}
		
		#tools > .scores{
			border: 1px solid #ddd;
		}
		
		#tools > .review > *{
			display: inline-block;
			width: 2rem;
			height: 2rem;
			margin: 0.2rem;
			padding: 0.3rem;
			background-color: #ddd;
			border: 3px outset #ddd;
			box-shadow: 1px 1px 2px #888,
				3px 3px 2px #888;
		}
		#tools > .review > *:active{
			background-color: #ccc;
			border: 3px inset #ddd;
		}
		</style>
		
		<!-- jquery -->
		<script src="./js/jquery.min.js"></script>
		<script>
		if (typeof require != "undefined") //electron
			window.$ = window.jQuery = require("./js/jquery.min.js");
		</script>
		
		<!-- babylon.js -->
		<script src="./js/babylon.min.js"></script>
		<!-- stats.js -->
		<script src="./js/stats.min.js"></script>
		
		<!-- layui -->
		<!--<link rel="stylesheet" href="https://unpkg.com/layui@2.6.4/dist/css/layui.css">
		<script src="https://unpkg.com/layui@2.6.8/dist/layui.js"></script>-->
		<script src="./layui/layui.js"></script>
		<link rel="stylesheet" href="./layui/css/layui.css">
		
		<script src="https://cdn.jsdelivr.net/npm/eruda"></script>
		<script src="https://cdn.bootcss.com/vConsole/3.3.4/vconsole.min.js"></script>
		<script>
		if ( /ipad|iphone|midp|rv:1.2.3.4|ucweb|android|windows ce|windows mobile/.test( navigator.userAgent.toLowerCase() ) ){
			//手机
			eruda.init();
			new VConsole();
		}
		</script>
		
		<script src="./js/js_plus.min.js"></script> <!-- js+ -->
		
	</head>
	<body>
		<header id="header">
			<i id="back" class="layui-icon layui-icon-return"></i>
			<h1>双人对战 3D</h1>
			<i id="restart" class="layui-icon layui-icon-refresh"></i>
		</header>
		
		<section id="main">
			<div class="side opposite white">
				<i></i>
				<div>
					<p class="name"></p>
					<p class="time">
						局时：<span class="total">10:00</span> &nbsp;
						步时：<span class="step">45s</span>
					</p>
				</div>
			</div>
			<canvas id="board"></canvas>
			<div class="fill"></div>
			<div class="side self black">
				<div>
					<p class="name"></p>
					<p class="time">
						局时：<span class="total">10:00</span> &nbsp;
						步时：<span class="step">45s</span>
					</p>
				</div>
				<i></i>
			</div>
			<div id="toolBtn">
				<button class="scores">棋局<br>评分</button>
				<button class="analyse">棋局<br>分析</button>
				<button class="review" disabled>复盘<br>回放</button>
			</div>
			<div id="layerControl">
				<i class="add layui-icon layui-icon-addition"></i>
				<i class="sub layui-icon layui-icon-subtraction"></i>
			</div>
			<div id="heightControl">
				<i class="add layui-icon layui-icon-up"></i>
				<i class="sub layui-icon layui-icon-down"></i>
			</div>
			<div id="tools">
				<canvas class="scores" height="36" style="display: none;"></canvas>
				<div class="review" style="display: none;">
					<svg class="last" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" xmlns:xlink="http://www.w3.org/1999/xlink">
						<polygon points="94.65,10 25.35,50 94.65,90 94.65,10" />
						<polygon points="5.35,10 25.35,10 25.35,90 5.35,90" />
					</svg>
					<svg class="play" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" xmlns:xlink="http://www.w3.org/1999/xlink">
						<polygon points="6.7,0 93.3,50 6.7,100 6.7,0" />
					</svg>
					<svg class="stop" style="display: none;" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" xmlns:xlink="http://www.w3.org/1999/xlink">
						<polygon points="20,0 40,0 40,100 20,100" />
						<polygon points="60,0 80,0 80,100 60,100" />
					</svg>
					<svg class="next" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100" xmlns:xlink="http://www.w3.org/1999/xlink">
						<polygon points="5.35,10 74.65,50 5.35,90 5.35,10" />
						<polygon points="94.65,10 74.65,10 74.65,90 94.75,90" />
					</svg>
				</div>
			</div>
		</section>
		
<script>
//生成任意维数组
Array.new = function(value, len, ...num){
	if (num.length == 0){
		if (value instanceof Function){
			return Array.from({
				length: len
			}, value);
		}else{
			return Array.from({
				length: len
			}, ()=>value);
		}
	}else{
		return Array.from({
			length: len
		}, ()=>Array.new(value, ...num));
	}
};
</script>
<script>
let WIDTH;
function resize(){
	console.log("resize")
	$("#board").attr("width", innerWidth)
		.attr("height", innerHeight);
	if (board.engine)
		board.engine.resize(); //更新大小
	
	const width = innerWidth-20,
		height = innerHeight
			-$("#header").height()
			-$("#main > .side").height()*2
			-$("#toolBtn").height();
	$("#main > .fill").css("width", width + "px")
		.css("height", height + "px");
	
	$("#tools > .scores").attr("width", innerWidth-18);
}
resize();
$(window).resize(resize);
</script>
<script>
$("html").addClass("fadeIn");
function go(url){
	$("html").addClass("outDown");
	setTimeout(function(){
		location.href = url;
	}, 600);
	layer.load(0);
}



class Board{
	constructor ({canvas, background, rows, columns, depth, none, mistake, black, white, winLines, spacing}){
		this.canvas = canvas;
		this.width = canvas.width;
		this.height = canvas.height;
		this.background = background;
		
		this.columns = columns;
		this.rows = rows;
		this.depth = depth;
		
		this.columnRange = [0, columns-1]; //列范围
		this.rowRange = [0, rows-1]; //行范围
		this.depthRange = [0, depth-1]; //深度范围
		this.surfaceOnly = true; //默认仅显示表面一层
		
		this.none = none; //空气配置
		this.mistake = mistake; //防误触配置
		this.black = black; //黑棋配置
		this.white = white; //白棋配置
		this.winLines = winLines; //获胜划线材质
		
		this.spacing = spacing; //间隔
		this.lines = { //划线
			win: [],
			analyse: []
		};
	}
	
	//载入场景
	loadScene(){
		//stats.js
		this.stats = new Stats();
		this.stats.showPanel(0);
		$("#main").append(
			$(this.stats.dom)
				.css("top", "calc(2em + 2 * 0.3rem)")
				.css("left", "auto")
				.css("right", "0")
				.css("opacity", "0.5")
		);
		
		//引擎 场景 相机
		this.engine = new BABYLON.Engine(this.canvas); //引擎
		this.engine.enableOfflineSupport = false; //不支持离线 以减少内存
		this.scene = new BABYLON.Scene(this.engine, {
			//useGeometryIdsMap: true,
			//useMaterialMeshMap: true,
			//useClonedMeshMap: true
		}); //场景
		this.scene.clearColor = new BABYLON.Color3(...this.background); //背景颜色
		this.camera = new BABYLON.ArcRotateCamera( //弧形旋转相机
			"Camera",
			-Math.PI/2, //alpha=-90°
			Math.PI/4, //beta=45°
			300, //radius
			BABYLON.Vector3.Zero(), //position
			this.scene
		);
		this.camera.attachControl(this.canvas, false);
		this.cameraInitPosition = this.camera.position.clone();
		
		//添加光
		this.hemisphericLight = new BABYLON.HemisphericLight( //模拟环境光
			"hemisphericLight",
			new BABYLON.Vector3(0, 1, 0),
			this.scene
		);
		this.directionalLight = new BABYLON.DirectionalLight( //平行光
			"directionalLight",
			new BABYLON.Vector3(0.6, 1, 0.6), //方向（斜向上）
			this.scene
		);
		this.directionalLight.intensity = 0.6; //亮度
		
		//所有棋子模板
		this.materials = {}; //材质
		this.templates = {}; //网格模板
		for (const name of ["none", "mistake", "black", "white"]){
			const material = new BABYLON.StandardMaterial("material_"+name, this.scene); //空气材质
			if ( this[name].color[0] )
				material.diffuseColor = new BABYLON.Color3(...this[name].color[0]); //漫反射颜色
			if ( this[name].color[1] )
				material.specularColor = new BABYLON.Color3(...this[name].color[1]); //镜面颜色
			if ( this[name].color[2] )
				material.emissiveColor = new BABYLON.Color3(...this[name].color[2]); //自发光颜色
			if ( this[name].color[3] )
				material.ambientColor = new BABYLON.Color3(...this[name].color[3]); //环境光颜色
			material.freeze();
			this.materials[name] = material;
			
			let template;
			if (name == "none" || name == "mistake"){ //方块
				template = BABYLON.MeshBuilder.CreateBox(
					"piece_template_"+name,
					{size: this[name].size}, //边长
					this.scene
				);
			}else{ //球
				template = BABYLON.MeshBuilder.CreateSphere(
					"piece_template_"+name,
					{diameter: this[name].size}, //边长
					this.scene
				);
			}
			template.material = material;
			template.isVisible = false; //隐藏
			template.freezeWorldMatrix();
			this.templates[name] = template;
		}
		//获胜划线材质
		const material = new BABYLON.StandardMaterial("material_winLines", this.scene); //空气材质
		if ( this.winLines.color[0] )
			material.diffuseColor = new BABYLON.Color3(...this.winLines.color[0]); //漫反射颜色
		if ( this.winLines.color[1] )
			material.specularColor = new BABYLON.Color3(...this.winLines.color[1]); //镜面颜色
		if ( this.winLines.color[2] )
			material.emissiveColor = new BABYLON.Color3(...this.winLines.color[2]); //自发光颜色
		if ( this.winLines.color[3] )
			material.ambientColor = new BABYLON.Color3(...this.winLines.color[3]); //环境光颜色
		material.freeze();
		this.materials.winLines = material;
		
		
		//生成所有位置
		this.pieces = Array.new(null, this.columns, this.rows, this.depth);
		this.clear();
		
		this.scene.blockMaterialDirtyMechanism = true;
		
		
		//渲染循环
		this.engine.runRenderLoop(()=>{
			this.stats.update(); //stats.js更新
			this.scene.render();
		});
	}
	
	//进入动画
	intoAnimation(time){
		return new Promise((resolve, reject)=>{
			const easingFunction = new BABYLON.CircleEase(); //缓动函数
			easingFunction.setEasingMode( BABYLON.EasingFunction.EASINGMODE_EASEINOUT ); //模式
			
			//由小变大
			const sizeAnimation = new BABYLON.Animation(
				"animation_size", //名称
				"scaling", //属性
				30, //FPS
				BABYLON.Animation.ANIMATIONTYPE_VECTOR3, //属性类型
				BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT //仅一次
			);
			sizeAnimation.setKeys([ //关键帧
				{ frame: 0, value: new BABYLON.Vector3(0,0,0) },
				{ frame: 100, value: new BABYLON.Vector3(1,1,1) }
			]);
			sizeAnimation.setEasingFunction( easingFunction ); //缓动函数
			
			//由透明变不透明
			/*const alphaAnimation = new BABYLON.Animation(
				"animation_alpha", //名称
				"material.alpha", //属性
				30, //FPS
				BABYLON.Animation.ANIMATIONTYPE_FLOAT, //属性类型
				BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT //仅一次
			);
			alphaAnimation.setKeys([ //关键帧
				{ frame: 0, value: 0 },
				{ frame: 100, value: 1 }
			]);
			alphaAnimation.setEasingFunction( easingFunction ); //缓动函数*/
			
			for (let i=this.columns-1; i>=0; i--)
				for (let j=this.rows-1; j>=0; j--)
					for (let k=this.depth-1; k>=0; k--){
						const mesh = this.pieces[i][j][k];
						if (!mesh) continue; //无棋子
						const comeInAnimation = new BABYLON.Animation(
							"animation_comeIn", //名称
							"position", //属性
							30, //FPS
							BABYLON.Animation.ANIMATIONTYPE_VECTOR3, //属性类型
							BABYLON.Animation.ANIMATIONLOOPMODE_CONSTANT //仅一次
						);
						comeInAnimation.setKeys([ //关键帧
							{ frame: 0, value: new BABYLON.Vector3(0,0,0) },
							{ frame: 100, value: new BABYLON.Vector3(...this.ijk2xyz(i,j,k)) }
						]);
						comeInAnimation.setEasingFunction( easingFunction ); //缓动函数
						mesh.animations = [comeInAnimation, sizeAnimation]; //设置到物体
						//this.scene.beginAnimation(mesh, 0, 100, false, 1, resolve); //开始动画 不循环
					}
			for (let i=this.columns-1; i>=0; i--)
				for (let j=this.rows-1; j>=0; j--)
					for (let k=this.depth-1; k>=0; k--){
						const mesh = this.pieces[i][j][k];
						if (mesh)
							this.scene.beginAnimation(mesh, 0, 100, false, 1, resolve); //开始动画 不循环
					}
		});
	}
	
	//棋子序号 转 场景坐标
	ijk2xyz(i, j, k){
		return [
			(i - (this.columns-1)/2 ) * this.spacing.x,
			(j - (this.rows-1)/2 ) * this.spacing.y,
			(k - (this.depth - 1)/2 ) * this.spacing.z
		];
	}
	//场景坐标 转 棋子序号
	xyz2ijk(x, y, z){
		return [
			Math.round( x/this.spacing.x + (this.columns - 1)/2 ),
			Math.round( y/this.spacing.y + (this.rows - 1)/2 ),
			Math.round( z/this.spacing.z + (this.depth - 1)/2 )
		];
	}
	
	//添加棋子
	add(i, j, k, type){
		const piece = this.templates[type].clone(`place(${i},${j},${k})`);
		piece.isVisible = true; //显示
		piece.position.set( ...this.ijk2xyz(i, j, k) );
		piece.freezeWorldMatrix();
		piece.cullingStrategy = BABYLON.AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY; //网格剔除策略：边界球
		this.pieces[i][j][k] = piece;
		return this;
	}
	
	//隐藏棋子
	visible(i, j, k, visible){
		//if (this.pieces[i][j][k])
			this.pieces[i][j][k].isVisible = visible;
		return this;
	}
	
	//删除棋子
	remove(i, j, k){
		if (this.pieces[i][j][k])
			this.pieces[i][j][k].dispose();
		this.pieces[i][j][k] = null;
		return this;
	}
	
	//设置棋子
	set(i, j, k, type){
		switch (type){
			/*case null: //隐藏
				if (this.pieces[i][j][k]) //有棋子
					this.remove(i, j, k);
				break;*/
				
			case "none": //空气
				if (this.pieces[i][j][k]){ //有棋子
					this.visible(i, j, k, true); //显示
					if (this.pieces[i][j][k].material == this.materials.none)
						return; //类型相同不改
					if (this.pieces[i][j][k].material == this.materials.mistake) //同形状 改材质
						return (this.pieces[i][j][k].material = this.materials.none);
					this.remove(i, j, k); //否则删除原有棋子
				}
				this.add(i, j, k, "none"); //添加棋子
				break;
				
			case "mistake": //防误触
				if (this.pieces[i][j][k]){ //有棋子
					this.visible(i, j, k, true); //显示
					if (this.pieces[i][j][k].material == this.materials.mistake)
						return; //类型相同不改
					if (this.pieces[i][j][k].material == this.materials.none) //同形状 改材质
						return (this.pieces[i][j][k].material = this.materials.mistake);
					this.remove(i, j, k); //否则删除原有棋子
				}
				this.add(i, j, k, "mistake"); //添加棋子
				break;
				
			case "black": //黑棋
				if (this.pieces[i][j][k]){ //有棋子
					this.visible(i, j, k, true); //显示
					if (this.pieces[i][j][k].material == this.materials.black)
						return; //类型相同不改
					if (this.pieces[i][j][k].material == this.materials.white) //同形状 改材质
						return (this.pieces[i][j][k].material = this.materials.black);
					this.remove(i, j, k); //否则删除原有棋子
				}
				this.add(i, j, k, "black"); //添加棋子
				break;
				
			case "white": //白棋
				if (this.pieces[i][j][k]){ //有棋子
					this.visible(i, j, k, true); //显示
					if (this.pieces[i][j][k].material == this.materials.white)
						return; //类型相同不改
					if (this.pieces[i][j][k].material == this.materials.black) //同形状 改材质
						return (this.pieces[i][j][k].material = this.materials.white);
					this.remove(i, j, k); //否则删除原有棋子
				}
				this.add(i, j, k, "white"); //添加棋子
				break;
				
		}
	}
	
	//清除棋子
	clear(){
		for (let i=this.columns-1; i>=0; i--)
			for (let j=this.rows-1; j>=0; j--)
				for (let k=this.depth-1; k>=0; k--){
					this.set(i, j, k, "none");
					if ( this.surfaceOnly && //仅显示表面一层
							!( i == this.columnRange[0] || i == this.columnRange[1] ||
							j == this.rowRange[0] || j == this.rowRange[1] ||
							k == this.depthRange[0] || k == this.depthRange[1] ) //不在表面
					){
						this.visible(i, j, k, false);
					}else if ( !( i >= this.columnRange[0] && i <= this.columnRange[1] &&
						j >= this.rowRange[0] && j <= this.rowRange[1] &&
						k >= this.depthRange[0] && k <= this.depthRange[1] ) //全部显示 且 不在加载范围内
					){
						this.visible(i, j, k, false);
					}
				}
		
		return this;
	}
	
	
	//添加划线
	addLine(from, to, width=1, material){
		const [x0, y0, z0] = from,
			[x1, y1, z1] = to,
			[dx, dy, dz] = to.map((v,i) => v-from[i]),
			len = Math.sqrt(dx*dx + dy*dy + dz*dz),
			line = BABYLON.MeshBuilder.CreateCylinder(
				"cylinder_line",
				{
					height: len,
					diameter: width, //直径
					tessellation: 8, //细分度
					heightSubdivs: 1 //高度细分度
				},
				this.scene
			);
		line.position = new BABYLON.Vector3(
			...to.map( (v,i) => (v+from[i])/2 ) //取平均值
		);
		const symbolX = dx>=0? +1: -1; //dx的符号
		line.addRotation(0, 0, -Math.PI/2)
			.addRotation(Math.atan(dz && dz/dx), 0, 0)
			.addRotation(0, 0, Math.atan(dy / (symbolX * Math.sqrt(dx*dx + dz*dz)) ));
		if (material)
			line.material = this.materials[material];
		console.log(material, width, from, to, line.position, line.rotation)
		return line;
	}
	
	//删除划线
	removeLines(...lines){
		for (const line of lines)
			line.dispose();
		return this;
	}
	
	//清空划线
	clearLines(type){
		if (type){
			this.removeLines(...this.lines[type]); //删除所有划线
			this.lines[type] = [];
		}else{
			this.removeLines(...this.lines.win, ...this.lines.analyse); //删除所有划线
			this.lines.win = [];
			this.lines.analyse = [];
		}
		return this;
	}
	
	//层增大
	layerAdd(){
		if (this.columnRange[0] <= 0) return this;
		if (this.columnRange[1] >= this.columns-1) return this;
		if (this.rowRange[0] <= 0) return this;
		if (this.rowRange[1] >= this.rows-1) return this;
		if (this.depthRange[0] <= 0) return this;
		if (this.depthRange[1] >= this.depth-1) return this;
		
		this.columnRange[0]--;
		this.columnRange[1]++;
		this.rowRange[0]--;
		this.rowRange[1]++;
		this.depthRange[0]--;
		this.depthRange[1]++;
		
		return this.update();
	}
	
	//层减小
	layerSub(){
		if (this.columnRange[0] == this.columnRange[1]) return this;
		if (this.columnRange[0]+1 == this.columnRange[1]) return this;
		if (this.rowRange[0] == this.rowRange[1]) return this;
		if (this.rowRange[0]+1 == this.rowRange[1]) return this;
		if (this.depthRange[0] == this.depthRange[1]) return this;
		if (this.depthRange[0]+1 == this.depthRange[1]) return this;
		
		this.columnRange[0]++;
		this.columnRange[1]--;
		this.rowRange[0]++;
		this.rowRange[1]--;
		this.depthRange[0]++;
		this.depthRange[1]--;
		
		return this.update();
	}
	
	//高度增加
	heightAdd(){
		if (this.rowRange[1] >= this.rows-1) return this;
		
		this.rowRange[1]++;
		
		return this.update();
	}
	
	//高度减小
	heightSub(){
		if (this.rowRange[1] <= this.rowRange[0]) return this;
		
		this.rowRange[1]--;
		
		return this.update();
	}
	
	//更新
	update(){
		for (let i=this.columns-1; i>=0; i--)
			for (let j=this.rows-1; j>=0; j--)
				for (let k=this.depth-1; k>=0; k--)
					if ( i >= this.columnRange[0] && i <= this.columnRange[1] &&
						j >= this.rowRange[0] && j <= this.rowRange[1] &&
						k >= this.depthRange[0] && k <= this.depthRange[1] && //在加载范围内
						( !this.surfaceOnly || //全部显示
							i == this.columnRange[0] || i == this.columnRange[1] ||
							j == this.rowRange[0] || j == this.rowRange[1] ||
							k == this.depthRange[0] || k == this.depthRange[1] //在表面
						)
					){
						this.visible(i, j, k, true);
					}else{
						this.visible(i, j, k, false);
					}
		
		return this;
	}
}

let waiting = false; //等待中
const {N=5, cols=10, rows=10, depth=10, place=0, mistake=true} = JSON.parse(localStorage.getItem("五子棋_游戏设置") || "{}");
const board = new Board({ //棋盘
	canvas: $("#board")[0],
	background: [0xff/0xff, 0xfa/0xff, 0xe8/0xff],
	rows,
	columns: cols,
	depth,
	none: {
		size: 6,
		color: [
			[0.9, 0.9, 0.9], //漫反射
			[1, 1, 1] //镜面反射
		]
	},
	mistake: {
		size: 6,
		color: [
			[0, 0, 1], //漫反射
			[0.6, 0.6, 1] //镜面反射
		]
	},
	black: {
		size: 8,
		color: [
			[0, 0, 0], //漫反射
			[0.8, 0.8, 0.8] //镜面反射
		]
	},
	white: {
		size: 8,
		color: [
			[1, 1, 1], //漫反射
			[1, 1, 1] //镜面反射
		]
	},
	winLines: {
		color: [
			[1, 0, 0], //漫反射
			[1, 0.8, 0.8], //镜面反射
			[0.2, 0.2, 0.2] //自发光颜色
		]
	},
	spacing: {x: 10, y: 10, z: 10}
});

const loadingId = layer.load(2);
setTimeout(()=>{
	board.loadScene();
	layer.close(loadingId);
	init();
}, 1000);


let game = {
		turn: 1, //下棋方 1:黑, 0:白
		startTime: null, //开始游戏时间
		steps: 0, //下棋总步数
		winner: false, //获胜者 1:黑, 0:白, null:平 false:未获胜
		t0: [null, null], //上次时间
		ids: [null, null], //计时器id
		time: [
			{total: 600, step: 45}, //0: 白
			{total: 600, step: 45} //1: 黑
		], //剩余时间
		timeWarning: { //时间警告
			total: {
				60: ["#f00", 1.2],
				180: ["#fa0", 1.1],
				600: ["#000", 1]
			},
			step: {
				10: ["#f00", 1.5],
				20: ["#fa0", 1.1],
				45: ["#000", 1]
			}
		},
		scores: {
			now: [0, 0], //当前
			goal: [0, 0], //目标
			t0: +new Date(),
			k: 0.005
		}, //分数 白:0 黑:1
		lines: [], //连线
		linesDisplay: false, //显示连线
		
		//更新时间显示
		updateTime(turn){
			let total, step,
				totalElem, stepElem;
			
			//黑
			total = Math.max(this.time[1].total, 0);
			step = Math.max(this.time[1].step, 0);
			
			totalElem = $("#main > .black > div > .time > .total"),
			stepElem = totalElem.next(".step");
			
			totalElem.html(
				( ~~(total/60) +"").padStart(2,"0") + ":" + ( ~~total%60 +"").padStart(2, "0")
			);
			for (const [i,v] of Object.entries(this.timeWarning.total))
				if (total <= i){
					totalElem.css("color", v[0])
						.css("font-size", v[1] + "em");
					break;
				}
			
			stepElem.html(
				~~step + "s"
			);
			for (const [i,v] of Object.entries(this.timeWarning.step))
				if (step <= i){
					stepElem.css("color", v[0])
						.css("font-size", v[1] + "em");
					break;
				}
			
			if (~~step < 10 && ~~step >= 9)
				this.flash(this.turn, "#f00"); //背景闪烁
			
			//白
			total = Math.max(this.time[0].total, 0);
			step = Math.max(this.time[0].step, 0);
			
			totalElem = $("#main > .white > div > .time > .total"),
			stepElem = totalElem.next(".step");
			
			totalElem.html(
				( ~~(total/60) +"").padStart(2,"0") + ":" + ( ~~total%60 +"").padStart(2, "0")
			);
			for (const [i,v] of Object.entries(this.timeWarning.total))
				if (total <= i){
					totalElem.css("color", v[0])
						.css("font-size", v[1] + "em");
					break;
				}
			
			stepElem.html(
				~~step + "s"
			);
			for (const [i,v] of Object.entries(this.timeWarning.step))
				if (step <= i){
					stepElem.css("color", v[0])
						.css("font-size", v[1] + "em");
					break;
				}
			
			if (~~step < 10 && ~~step >= 9)
				this.flash(this.turn, "#f00"); //背景闪烁
		},
		
		//背景闪烁
		flash(turn, color){
			let elem;
			if (this.turn == 1){ //黑
				elem = $("#main > div.black > i");
			}else{ //白
				elem = $("#main > div.white > i");
			}
			elem.css("background-color", color);
			setTimeout(()=> elem.css("background-color", ""), 150);
			setTimeout(()=> elem.css("background-color", color), 300);
			setTimeout(()=> elem.css("background-color", ""), 450);
		},
		
		//切换下棋方
		set(turn){
			if (this.time[this.turn].total <= 0){ //超出局时
				this.time[this.turn].step += 5;
			}else{
				this.time[this.turn].step = 45; //重置步时
				//this.time[this.turn].total += 5; //增加局时
			}
			this.updateTime(this.turn);
			clearInterval( this.ids[this.turn] );
			
			this.turn = turn;
			this.flash(this.turn, "#af8"); //背景闪烁
			this.t0[this.turn] = +new Date();
			this.ids[this.turn] = setInterval(()=>{
				const interval = (new Date() - this.t0[this.turn]) / 1000;
				this.t0[this.turn] = +new Date();
				
				this.time[this.turn].total -= interval;
				this.time[this.turn].step -= interval;
				this.updateTime(this.turn);
				
				if (this.time[this.turn].step <= 0){ //超出步时
					this.winner = 1-this.turn;
					clearInterval( this.ids[this.turn] );
					$("#toolBtn > .review").removeAttr("disabled"); //解除禁用
					//worker.terminate(); //关闭线程
					const t = (new Date() - game.startTime) / 1000;
					layer.alert(`${this.turn==1? "黑方": "白方"}超时<br>历时${~~(t/60)}分${~~t%60}秒<br>${game.steps}步（${game.steps/2}回合）`,
						{title: "游戏结束！"}
					);
				}
				
			}, 200);
		},
		
		//更新分数
		updateScores(){
			const t = new Date()-this.scores.t0,
				now = this.scores.now,
				goal = this.scores.goal,
				k = this.scores.k,
				e = $("#tools > .scores");
			this.scores.t0 = +new Date();
			if (t > 300) return; //跳帧
			
			now[0] += (goal[0] - now[0]) *t *k;
			now[1] += (goal[1] - now[1]) *t *k;
			
			const black = now[1] + 0.001,
				white = now[0] + 0.001,
				total = black + white,
				ctx = e[0].getContext("2d"),
				width = e.attr("width"),
				height = e.attr("height");
			
			//清除背景
			ctx.beginPath();
			ctx.fillStyle = "#fff";
			ctx.fillRect(0, 0, width, height);
			
			//背景
			ctx.beginPath();
			ctx.fillStyle = "#000";
			ctx.moveTo(0, 0);
			ctx.lineTo(black / total * width + 5, 0);
			ctx.lineTo(black / total * width - 5, height);
			ctx.lineTo(0, height);
			ctx.fill();
			
			ctx.beginPath();
			ctx.fillStyle = "#fff";
			ctx.moveTo(width, 0);
			ctx.lineTo(black / total * width + 5, 0);
			ctx.lineTo(black / total * width - 5, height);
			ctx.lineTo(width, height);
			ctx.fill();
			
			//文字
			ctx.beginPath();
			ctx.fillStyle = "#fff"; //白字
			ctx.textAlign = "left";
			ctx.textBaseline = "top"; //基线：左上
			ctx.font = height*5/6 + "px xs"; // 5/6vh
			ctx.shadowOffsetX = 1;
			ctx.shadowOffsetY = 1;
			ctx.shadowColor = "#000";
			ctx.shadowBlur = 3;
			ctx.fillText(Math.round(black-0.001, 2), height/6, height/12); //margin: 0.2vh ;0.1vh
			
			ctx.beginPath();
			ctx.fillStyle = "#000"; //黑字
			ctx.textAlign = "right";
			ctx.textBaseline = "top"; //基线：右上
			ctx.font = height*5/6 + "px xs"; // 5/6vh
			ctx.shadowOffsetX = 1;
			ctx.shadowOffsetY = 1;
			ctx.shadowColor = "#fff";
			ctx.shadowBlur = 3;
			ctx.fillText(Math.round(white-0.001, 2), width-height/6, height/12); //margin: 0.2vh ;0.1vh
		},
		
		//更新分析画线
		updateLines(display=true){
			board.clearLines("analyse");
			
			if (display) //需显示
				for (const v of this.lines)
					if (v.width >= 3) //连子>=3 避免过密
						board.lines.analyse.push(
							board.addLine(
								v.start,
								v.end,
								(v.width-3+1)/2,
								v.pic==2? "white": "black"
							)
						);
			
			game.linesDisplay = display;
		}
	},
	worker,
	workerCallback = {  //收到消息回调
		//获胜
		won(data){
			const {winner, steps} = data;
			game.winner = winner;
			clearInterval( game.ids[game.turn] ); //停止计时 不关闭线程
			$("#toolBtn > button.review").removeAttr("disabled"); //解除禁用
			const t = (new Date() - game.startTime) / 1000;
			layer.alert(`${winner==2? "黑方": "白方"}胜<br>历时${~~(t/60)}分${~~t%60}秒<br>${steps}步（${steps/2}回合）`,
				{title: "游戏结束！"}
			);
		},
		
		//获胜画线
		lines(data){
			const {lines} = data;
			
			lines.forEach( v => {
				[v.start[0], v.start[1], v.start[2]] = board.ijk2xyz(...v.start, place);
				[v.end[0], v.end[1], v.end[2]] = board.ijk2xyz(...v.end, place);
			});
			
			board.clearLines("win");
			for (const v of lines)
				board.lines.win.push(
					board.addLine(
						v.start,
						v.end,
						(0.1+N-3+1)/2,
						"winLines"
					)
				);
			
			//worker.terminate(); //关闭线程
		},
		
		//平局
		gameOver(){
			game.winner = null;
			clearInterval( game.ids[game.turn] ); //停止计时
			$("#toolBtn > .review").removeAttr("disabled"); //解除禁用
			//worker.terminate(); //关闭线程
			const t = (new Date() - game.startTime) / 1000;
			layer.alert(`平局<br>历时${~~(t/60)}分${~~t%60}秒<br>${game.steps}步（${game.steps/2}回合）`,
				{title: "游戏结束！"}
			);
		},
		
		//分析
		scores(data){
			console.table(data.scores);
			
			const {scores, lines} = data;
			lines.forEach( v => {
				[v.start[0], v.start[1], v.start[2]] = board.ijk2xyz(...v.start, place);
				[v.end[0], v.end[1], v.end[2]] = board.ijk2xyz(...v.end, place);
			});
			
			game.scores.goal = scores;
			game.lines = lines;
			
			if (game.linesDisplay){ //已显示
				game.updateLines(true);
			}else{
				game.updateLines(false);
			}
		}
	},
	review_id = null; //复盘id



//初始化
function init(){
	//棋盘
	board.clearLines(); //删除所有划线
	waiting = true; //禁止点击
	board.clear().intoAnimation().then(()=>{
		game.startTime = +new Date();
		game.set(1); //黑棋先下
		waiting = false; //允许点击
	});
	
	//游戏
	game.steps = 0;
	game.startTime = +new Date();
	game.turn = 1;
	game.winner = false;
	clearInterval( game.ids[0] );
	clearInterval( game.ids[1] ); //时间暂停
	game.t0[0] = game.t0[1] = game.ids[0] = game.ids[1] = null;
	game.time[0].total = 600;
	game.time[0].step = 45;
	game.time[1].total = 600;
	game.time[1].step = 45;
	game.scores.now[0] = game.scores.now[1] =
		game.scores.goal[0] = game.scores.goal[1] = 0;
	game.scores.t0 = +new Date();
	game.scores.k = 0.005;
	game.lines = []; //清空分析画线
	
	//停止复盘
	clearInterval(review_id);
	review_id = null;
	
	//线程
	if (worker)
		worker.terminate(); //关闭线程
	worker = new Worker("./js/worker.js"); //多线程
	worker.postMessage({
		type: "init", //初始化
		cols,
		rows,
		depth,
		D: 3,
		N,
		mis: mistake
	});
	worker.onmessage = function(e){
		console.log("message: ", e.data.type, e.data)
		const type = e.data.type;
		if (workerCallback[type])
			workerCallback[type](e.data);
	};
	worker.onerror = function(e){
		console.error(`${e.message}\n\tat ${e.filename}:${e.lineno}`)
	};
	
	//禁用按钮
	$("#toolBtn > .review").attr("disabled", "disabled");
	$("#tools > .review").slideUp("fast");
}
//setTimeout(init, 1000); //等待淡入动画结束



//请求线程
function request(data){
	console.log("post: ", data.type, data)
	worker.postMessage(data);
	return {
		then(func){
			workerCallback[data.type] = func;
		}
	};
}


const lastMistake = []; //上次防误触位置
$("#board").click(function(e){
	if (!worker) return; //未初始化线程
	if (game.winner !== false) return; //已结束
	if (waiting) return; //上次未响应
	
	const {offsetX: x, offsetY: y} = e;
	const pickResult = board.scene.pick(x, y);
	if (!pickResult.hit) return; //未点击到物体
	const pos = pickResult.pickedMesh.position,
		[i, j, k] = board.xyz2ijk(pos.x, pos.y, pos.z);
	console.log("click", pickResult, pos, [i, j, k])
	
	waiting = true; //开始等待
	
	request({
		type: "play", //下棋
		i, j, k
	}).then((data)=>{
		waiting = false;
		console.log("play callback:", data.action, {i,j,k})
		switch (data.action){
			case 2: //下黑棋
				board.set(i, j, k, "black");
				game.set(0);
				game.steps++;
				break;
				
			case 1: //下白棋
				board.set(i, j, k, "white");
				game.set(1);
				game.steps++;
				break;
				
			case -2: //添加标记
				lastMistake.splice(0, 3);
				lastMistake.push(i, j, k);
				board.set(i, j, k, "mistake");
				break;
				
			case -1: //删除标记
				console.log(lastMistake)
				board.set(...lastMistake, "none");
				break;
		}
	});
});



/* header */
//返回
$("#back").click(function(){
	go("index.html");
});

//重来
$("#restart").click(init);


/* control */
$("#layerControl > .add").click(function(){
	board.layerAdd();
});
$("#layerControl > .sub").click(function(){
	board.layerSub();
});
$("#heightControl > .add").click(function(){
	board.heightAdd();
});
$("#heightControl > .sub").click(function(){
	board.heightSub();
});


/* tools */
//评分
let scoresUpdateId;
function scores(display){
	const btn = $("#toolBtn > .scores"),
		tool = $("#tools > .scores");
	if ( display === true || //欲显示
		(display === undefined && tool.css("display") == "none") //已隐藏
	){
		clearInterval( scoresUpdateId ); //停止更新
		scoresUpdateId = setInterval(()=>game.updateScores(), 30); //更新分数
		
		btn.attr("disabled", "disabled");
		tool.slideDown("slow", ()=>btn.removeAttr("disabled"));
		
	}else{
		clearInterval( scoresUpdateId ); //停止更新
		scoresUpdateId = null;
		
		btn.attr("disabled", "disabled");
		tool.slideUp("slow", ()=>btn.removeAttr("disabled"));
	}
}
$("#toolBtn > .scores").click(function(){
	if ( $("#tools > .review").css("display") != "none" ){
		scores(false);
		return layer.msg("复盘时暂不支持棋局评分");
	}
	scores();
});

//分析
function analyse(display){
	if ( display === false || //欲隐藏
		(display === undefined && game.linesDisplay) //已显示
	){
		game.updateLines(false);
		layer.msg("棋局分析已关闭");
	}else{
		game.updateLines(true);
		layer.msg("棋局分析已开启");
	}
}
$("#toolBtn > .analyse").click(function(){
	if ($("#tools > .review").css("display") != "none"){
		analyse(false);
		return layer.msg("复盘时暂不支持棋局分析");
	}
	analyse();
});

//重放
let restore; //重置函数
$("#toolBtn > .review").click(function(){
	if ( $("#tools > .review").css("display") == "none" ){ //需显示
		$(this).attr("disabled", "disabled");
		$("#tools > .review").slideToggle("slow", ()=>$(this).removeAttr("disabled"));
		
		scores(false); //关闭棋局评分
		analyse(false); //关闭棋局分析
		$("#tools > .review > .stop").hide();
		$("#tools > .review > .play").show(); //暂停
		
		request({
			type: "review" //重放
		}).then((data)=>{
			const {steps, pieces} = data,
				winLines = board.lines.win;
			winLines.forEach(line => line.isVisible=false); //隐藏获胜划线
			board.clearLines("analyse"); //删除分析划线
			board.clear(); //清空棋子
			
			let index = -1;
			
			const next = ()=>{
					if (index >= steps.length-1){
						winLines.forEach(line => line.isVisible=true); //显示获胜划线
						return layer.msg("不能再往后了");
					}
					const {i,j,v} = steps[++index];
					return false;
				},
				last = ()=>{
					if (index <= 0)
						return layer.msg("不能再往前了"); 
					const {i,j,v} = steps[--index];
					winLines.forEach(line => line.isVisible=false); //隐藏获胜划线
					return false;
				};
			restore = ()=>{
				for (let i=this.columns-1; i>=0; i--)
					for (let j=this.rows-1; j>=0; j--)
						for (let k=this.depth-1; k>=0; k--)
							switch (pieces[i][j][k]){
								case 0:
									board.set(i, j, k, "none");
									break;
								case 1:
									board.set(i, j, k, "white");
									break;
								case 2:
									board.set(i, j, k, "black");
									break;
							}
			};
			
			next();
			
			$("#tools > .review > .last").click(last);
			$("#tools > .review > .next").click(next);
			
			$("#tools > .review > .play").click(function(){
				$(this).hide();
				$("#tools > .review > .stop").show();
				
				if (review_id)
					clearInterval(review_id);
				
				review_id = setInterval(()=>{
					if (next() === false) return;
					clearInterval(review_id);
					review_id = null;
					restore(); //重置
					$(this).show();
					$("#tools > .review > .stop").hide();
				}, 1000);
			});
			$("#tools > .review > .stop").click(function(){
				clearInterval(review_id);
				review_id = null;
				restore(); //重置
				$(this).hide();
				$("#tools > .review > .play").show();
			});
		});
		
	}else{
		clearInterval(review_id);
		review_id = null;
		restore(); //重置
		$(this).hide();
		$("#tools > .review > .play").show();
		
		$(this).attr("disabled", "disabled");
		$("#tools > .review").slideToggle("slow", ()=>$(this).removeAttr("disabled"));
	}
});
</script>
		
	</body>
</html>
